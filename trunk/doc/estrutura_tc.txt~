1. Emuladores
1.1 Níveis de abstração
1.1.1 Simuladores
1.1.2 Emuladores
1.1.3 Emuladores de alto nível
1.1.4 Virtualizadores
1.1.5 Paravirtualizadores
1.1.6 Outros
1.2 Filosofia de funcionamento
1.3 Tipos de emulação
1.3.1 Interpretação
1.3.2 Tradução binária estática
1.3.3 Tradução binária dinâmica
1.3.4 Virtualização
1.4 Pequena história da emulação
1.5 Usos atuais dos emuladores
1.5.1 Execução de software desenvolvido para outra plataforma
1.5.2 Execução de software legado
1.5.3 Ferramenta para desenvolvimento
1.5.4 Educacional

2. Arquitetura de hardware
2.1 Estrutura de um computador
2.2 CPU
2.2.1 Memória interna (flags e registradores)
2.2.2 Execução
2.2.2.1 Passos da execução (carregamento, decodificação, execução e retorno)
2.2.2.2 Tipos de conjuntos de instruções (CISC e RISC)
2.2.3 Interrupções
2.3 Memória
2.3.1 Memória ROM
2.3.2 Memória RAM
2.3.3 Memória endereçável
2.3.3.1 Mapas de memória
2.3.3.2 Espelhamento de memória (bancos de memória)
2.4 Gráficos
2.4.1 Funcionamento de um monitor (vsync, vblank, hsync, overscan e imagem visível)
2.4.2 Memória de Vídeo
2.4.3 Paleta
2.4.4 Tipos
2.4.4.1 Framebuffer
2.4.4.2 Sincronizado
2.4.4.3 Tiles/sprites
2.4.4.4 Vetorial
2.4.4.5 Tri-dimensional
2.5 Som
2.5.1 Efeitos sonoros pré-gravados
2.5.2 Efeitos sonoros baseados em onda
2.5.2.1 PSG
2.5.2.2 FM
2.5.3 Efeitos sonoros baseados em amostra
2.6 Dispositivos de Entrada
2.6.1 Sistemas de entrada
2.6.2 Teclado
2.6.3 Joystick
2.7 Dispositivos de armazenamento (?)
2.8 Outros dispositivos
2.9 Sincronia entre os dispositivos

3 Técnicas tradicionais de construção de emuladores
3.1 Estrutura de um emulador
3.2 CPU
3.3 Memória
3.3.1 Mapas de memória
3.3.1.1 Memória ROM
3.3.2 Espelhamento de memória
3.4 Gráficos
3.4.1 Framebuffer
3.4.2 Sincronizado
3.4.3 Tiles/sprites
3.5 Som
3.5.1 Efeitos sonoros pré-gravados
3.5.2 Efeitos sonoros baseados em onda
3.5.2.1 PSG
3.5.2.2 FM
3.5.3 Efeitos sonoros baseados em amostra
3.6 Dispositivos de entrada
3.7 Dispositivos de armazenamento (?)
3.8 Outros dispositivos
3.9 Sincronia entre os dispositivos
3.10 Obtenção de informações a respeito dos dispositivos

4 Problemas encontrados na criação tradicional de emuladores
4.1 Falta de modularização
4.1.1 Dificuldade no reaproveitamento de código
4.1.2 Impossibilidade no reaproveitamento de binários
4.2 Falta de portabilidade da plataforma de destino
4.3 Necessidade de reimplementação de tarefas padrão
4.3.1 Tarefas da plataforma de origem
4.3.2 Tarefas da plataforma de destino
4.3.3 Debuggers
4.4 Inflexibilidade do emulador para rodar diferentes tipos de software (ex. hblank)

5 Plano de ação
5.1 Filosofia de funcionamento
5.1.1 libemu
5.1.2 emutouch
5.1.3 emucc
5.1.4 emucheck
5.2 Funções da biblioteca
5.2.1 Conexão de módulos
5.2.2 Funções
5.2.3 Debuggers
5.3 Ferramentas utilizadas
5.4 Projetos semelhantes

6 Funcionamento da biblioteca
6.1 Carregamento dinâmico de módulos
6.2 Interface de usuário
6.3 Memória RAM
6.3.1 Debugger da memória
6.4 Microprocessador
6.4.1 Funcionamento interno (debugger, etc...)
6.5 Placa de vídeo
6.5.1 Funcionamento interno (saída de vídeo, etc...)
6.6 Outros dispositivos
6.6.1 Funcionamento interno
6.7 Sistema de entrada
6.7.1 Funcionamento interno
6.8 Memória ROM
6.8.1 Funcionmento Interno
6.9 Ciclo de operação

7 Criação de um emulador de Atari 2600 usando a biblioteca libemu
7.1 Histórico do Atari 2600
7.2 Componentes
7.2.1 CPU - MOS 6507
7.2.2 Gráficos - TIA 
7.2.2.1 "Truques" de programação
7.2.4 Dispositivo genérico - PIA 6532
7.2.5 Memória
7.2.5.1 Mapas de memória
7.2.5.2 Espelhamento de memória
7.2.6 Dispositivos de entrada
7.3 Análise do teste
Solução dos problemas...
